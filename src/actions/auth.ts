'use server';

import { supabaseAdmin } from '@/lib/supabase-admin';
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

// TODO: SEGURIDAD CRÍTICA - MEJORA REALIZADA
// Aunque hemos movido la autenticación al lado del servidor (evitando exponer credenciales),
// el short_id sigue siendo la contraseña. Si el ID es público (en gafetes), esto sigue siendo riesgoso.
// Se recomienda implementar un PIN o contraseña adicional en el futuro.

export async function registerUser(data: {
  firstName: string;
  lastName: string;
  degree: string;
  gender: string;
  email: string;
  phone: string;
}) {
  let userId: string | null = null;

  try {
    // 1. Create Auth User with temp password
    const tempPassword = Math.random().toString(36).slice(-8) + "A1!";
    
    const { data: userData, error: userError } = await supabaseAdmin.auth.admin.createUser({
      email: data.email,
      password: tempPassword,
      email_confirm: true, // Auto-confirm email
      user_metadata: {
        first_name: data.firstName,
        last_name: data.lastName,
      }
    });

    if (userError) {
        console.error("User creation error:", userError.message);
        // Supabase returns helpful error messages (e.g. "User already registered")
        return { success: false, error: userError.message };
    }

    if (!userData.user) {
        return { success: false, error: "No se pudo crear el usuario (sin datos)." };
    }

    userId = userData.user.id;

    // 2. Insert Profile
    // The Short ID is generated by a database trigger (BEFORE INSERT)
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .insert({
        id: userId,
        first_name: data.firstName,
        last_name: data.lastName,
        degree: data.degree,
        gender: data.gender,
        phone: data.phone,
        email: data.email
      })
      .select('short_id')
      .single();

    if (profileError) {
      console.error("Profile insertion error:", profileError);
      // CRITIQUE: If profile fails, we MUST delete the Auth User to keep consistency.
      await supabaseAdmin.auth.admin.deleteUser(userId);
      return { success: false, error: "Error al crear perfil: " + profileError.message };
    }

    const shortId = profile.short_id;

    // 3. Update password to shortId (CRITICAL STEP)
    // Retry logic mainly for network glitches or race conditions
    let updateSuccess = false;
    let lastError = null;

    for (let i = 0; i < 3; i++) {
        const { error: updateError } = await supabaseAdmin.auth.admin.updateUserById(userId, {
            password: shortId
        });
        
        if (!updateError) {
            updateSuccess = true;
            break;
        }

        console.warn(`Password update attempt ${i+1} failed:`, updateError);
        lastError = updateError;
        // Wait 300ms before retry
        await new Promise(res => setTimeout(res, 300));
    }

    if (!updateSuccess) {
       console.error("CRITICAL: Failed to set password to short_id after 3 attempts.", lastError);
       // EMERGENCY ROLLBACK: Delete the user and profile to avoid "zombie" account
       // Profile cascades on delete of Auth User usually, but we delete Auth User explicitly.
       await supabaseAdmin.auth.admin.deleteUser(userId);
       return { success: false, error: "Error de sistema al configurar cuenta. Por favor intente de nuevo." };
    }

    return { success: true, data: { short_id: shortId } };

  } catch (err: any) {
    console.error("Register Exception:", err);
    
    // Last resort cleanup if userId exists
    if (userId) {
        try {
            await supabaseAdmin.auth.admin.deleteUser(userId);
        } catch (cleanupErr) {
            console.error("Failed to cleanup user after exception:", cleanupErr);
        }
    }

    return { success: false, error: err.message || "Error desconocido al registrar" };
  }
}

export async function loginWithId(shortId: string) {
  try {
    // 1. Find email by short_id (using admin client since we don't have user session yet)
    const { data: profile, error } = await supabaseAdmin
      .from('profiles')
      .select('email')
      .eq('short_id', shortId)
      .single();

    if (error || !profile) {
      return { success: false, error: "ID no encontrado" };
    }

    // 2. Authenticate on Server Side setting cookies
    const cookieStore = await cookies();

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return cookieStore.getAll()
          },
          setAll(cookiesToSet) {
             try {
                cookiesToSet.forEach(({ name, value, options }) =>
                   cookieStore.set(name, value, options)
                )
             } catch (error) {
                // The `setAll` method was called from a Server Component.
                // This can be ignored if you have middleware refreshing user sessions.
             }
          },
        },
      }
    );
    
    // We sign in with the retrieved email and the short_id as password
    const { data: authData, error: signInError } = await supabase.auth.signInWithPassword({
      email: profile.email,
      password: shortId,
    });

    if (signInError) {
      console.error("Login Check Error:", signInError);
      return { success: false, error: "Credenciales inválidas o error de sesión" };
    }

    if (!authData.session) {
      return { success: false, error: "No se pudo establecer la sesión" };
    }

    console.log('[SERVER] Login successful, session established');

    // 3. Revalidate paths to clear cache
    const { revalidatePath } = await import('next/cache');
    revalidatePath('/profile', 'page');
    revalidatePath('/', 'page');
    
    // Return success with session info so client can verify
    return { 
      success: true, 
      sessionEstablished: true,
      userId: authData.user.id 
    };

  } catch (err: any) {
    console.error("Login Exception:", err);
    return { success: false, error: "Error al procesar login" };
  }
}

export async function checkEmailForRecovery(email: string) {
  try {
    const { data, error } = await supabaseAdmin
      .from('profiles')
      .select('email')
      .ilike('email', email)
      .single();

    if (error || !data) {
      return { success: false, error: "Correo no encontrado en nuestros registros" };
    }
    return { success: true };
  } catch (err: any) {
    return { success: false, error: "Error al verificar el correo" };
  }
}

export async function verifyRecoveredUser(email: string, phone: string) {
  try {
    const { data, error } = await supabaseAdmin
      .from('profiles')
      .select('short_id, phone')
      .ilike('email', email)
      .single();

    if (error || !data) {
      return { success: false, error: "Registro no encontrado" };
    }

    const dbPhone = (data.phone || '').replace(/\D/g, '');
    const inputPhone = phone.replace(/\D/g, '');

    if (dbPhone !== inputPhone) {
        return { success: false, error: "El número de celular no coincide con el correo proporcionado" };
    }

    return { success: true, short_id: data.short_id };

  } catch (err: any) {
    return { success: false, error: "Error al verificar datos" };
  }
}
